# Git Workflow Guide

## When to use `git commit --amend`
git commit --amend is useful when I just made a commit and want to fix something small, like a missing file or a typo in the message. It keeps the history clean by updating the last commit instead of creating a new one. I use it only when the commit has not been pushed to a shared branch. If it has been pushed, amending can rewrite history and cause problems for others. The main risks are breaking someone else’s work or creating conflicts. A simple example is forgetting to add a helper file, realizing it immediately, adding it, and running git commit --amend to update the last commit.

## When to use Interactive Rebase
Interactive rebase is best when I want to clean up a messy branch before sharing it or making a pull request. I can squash small commits into one, reorder commits to make the history make sense, or edit commit messages to be clearer. It improves the readability of the branch and makes the final history look professional. I mainly use it when working alone on a feature branch. Squashing helps remove useless “fix typo” or “wip” commits. Reordering helps keep the logic consistent, like putting setup commits before feature commits. Editing messages makes each commit easier to understand. I avoid interactive rebase on shared branches because rewriting history there can cause issues.

## When to use `git revert` vs `git reset`
git revert is used when a bad commit is already pushed and others have pulled it. Revert creates a new commit that undoes the changes safely without rewriting history. It keeps everyone’s branches consistent and avoids breaking the shared history.
git reset is used locally, mainly on branches that only I am modifying. It rewrites history by moving the HEAD pointer and changing commits. git reset --soft keeps changes staged, --mixed keeps them unstaged, and --hard resets everything. I never use reset on shared branches because it removes commits that others may be using. The main difference: revert is safe for collaboration; reset is for personal cleanup.

## Rules for Altering Commit History
I only rewrite history on branches that have not been pushed or that no one else is using. If a branch is private or new, it is safe to squash commits, reorder them, or amend them. If it is shared or other teammates have pulled it, I avoid rewriting history completely. Once a commit is public, it should stay as-is to avoid confusing others. Rewriting history on shared branches can cause merge conflicts, broken branches, or lost commits. A safe rule is: if anyone else might have the commit, I do not rewrite it. If I’m unsure, I keep the history as it is and use revert instead of reset or rebase.

## How to Recover from Mistakes Using `reflog`
git reflog shows every movement of the HEAD, even commits that look deleted. It is the best tool for recovering lost work, especially after using reset or rebase. If I accidentally reset too far or lose a commit during a rebase, I can run git reflog to see older commit references. Then I can restore them with git checkout <hash> or git reset --hard <hash>. It acts like a safety net for almost every mistake. Even commits not visible in git log can be found in the reflog. The general recovery process is: check reflog, find the commit, reset or cherry-pick it back into the branch.

## Team Collaboration Guidelines
Our team should follow a simple and clear workflow. Each feature should be developed on its own branch to keep main and develop stable. Branch names should describe their purpose, like feature-login or bugfix-profile. Commit messages should be short but clear, describing what changed and why. Before making a pull request, the branch should be cleaned with interactive rebase to remove noise. We should communicate when rewriting history, pushing large updates, or resolving conflicts. Shared branches like main and develop should never use reset or amended commits. Revert should be used to fix bad commits on shared branches. Everyone should pull frequently to reduce conflicts. Good communication and clean commit messages help the whole team stay organized and efficient.